declare const BASE_YEAR = 1900;
declare const BASE_MONTH = 1;
declare const BASE_DAY = 31;
declare const MAXIMUM_YEAR = 2100;
declare const MAXIMUM_LUNAR_YEAR = 2100;
declare const MAXIMUM_LUNAR_MONTH = 12;
declare const MAXIMUM_LUNAR_DAY = 1;
/**
 * 1900-2100 Hex
 * The high 12-digits of hexadecimal represent the number of days in each month of the lunar calendar,
 * and the low 4-digits represent leap month information.
 */
declare const LUNAR_DATA: number[];

declare const index_BASE_DAY: typeof BASE_DAY;
declare const index_BASE_MONTH: typeof BASE_MONTH;
declare const index_BASE_YEAR: typeof BASE_YEAR;
declare const index_LUNAR_DATA: typeof LUNAR_DATA;
declare const index_MAXIMUM_LUNAR_DAY: typeof MAXIMUM_LUNAR_DAY;
declare const index_MAXIMUM_LUNAR_MONTH: typeof MAXIMUM_LUNAR_MONTH;
declare const index_MAXIMUM_LUNAR_YEAR: typeof MAXIMUM_LUNAR_YEAR;
declare const index_MAXIMUM_YEAR: typeof MAXIMUM_YEAR;
declare namespace index {
  export { index_BASE_DAY as BASE_DAY, index_BASE_MONTH as BASE_MONTH, index_BASE_YEAR as BASE_YEAR, index_LUNAR_DATA as LUNAR_DATA, index_MAXIMUM_LUNAR_DAY as MAXIMUM_LUNAR_DAY, index_MAXIMUM_LUNAR_MONTH as MAXIMUM_LUNAR_MONTH, index_MAXIMUM_LUNAR_YEAR as MAXIMUM_LUNAR_YEAR, index_MAXIMUM_YEAR as MAXIMUM_YEAR };
}

/**
 * Return the lunar leap month in the year otherwise return 0
 * @param {number} year - lunar year
 * @returns {number} Leap month in a lunar year
 *
 * @example
 * // => 3
 * getLeapMonth(2023)
 *
 * @example
 * // => 0
 * getLeapMonth(2024)
 */
declare function getLeapMonth(year: number): number;

/**
 * Returns days in a lunar leap month if there is a leap month in the year otherwise return 0
 * @param {number} year - lunar year
 * @returns {number} Days in lunar leap month
 *
 * @example
 * // => 29
 * getLeapMonthDays(2023)
 *
 * @example
 * // => 0
 * getLeapMonthDays(2024)
 */
declare function getLeapMonthDays(year: number): number;

/**
 * Returns the number of days in a non-leap month of lunar
 * @param {number} year - lunar year
 * @param {number} month - lunar month
 * @returns {number} Days in lunar non-leap month
 *
 * @example
 * // => 29
 * getLeapMonth(2024, 12)
 *
 * @example
 * // => 30
 * getLeapMonth(2025, 1)
 *
 * @example
 * // => -1
 * getLeapMonth(1899, 13)
 */
declare function getMonthDays(year: number, month: number): number;

/**
 * Return the number of days in this lunar year
 * @param {number} year - lunar year
 * @returns {number} Days in lunar year
 *
 * @example
 * // => 354
 * getYearDays(2024)
 *
 * @example
 * // => 384
 * getYearDays(2025)
 *
 * @example
 * // => -1
 * getYearDays(1899)
 */
declare function getYearDays(year: number): number;

/**
 * Returns true if the given value is an instance of Date.
 * @param {*} value - The value to check
 * @returns {boolean} True if the given value is a date
 *
 * @example
 * isDate(new Date())
 * //=> true
 *
 * @example
 * // => true
 * isDate(new Date(NaN))
 *
 * @example
 * // => false
 * isDate('2014-02-31')
 *
 * @example
 * // => false
 * isDate({})
 */
declare function isDate(value: unknown): value is Date;

/**
 * Checks if the given value is a valid Date object. A valid date is an instance of `Date` and has a non-NaN time value.
 * @param {*} date - The value to check.
 * @returns {boolean} True if the value is a valid Date, otherwise false.
 *
 * @example
 * // => true
 * isValidDate(new Date())
 *
 * @example
 * // => false
 * isValidDate(new Date(NaN))
 *
 * @example
 * // => false
 * isValidDate('2014-02-31')
 */
declare function isValidDate(date: unknown): date is Date;

interface LunarDate {
    /** Lunar year */
    year: number;
    /** Lunar month */
    month: number;
    /** Lunar day */
    day: number;
    /** Lunar leap month flag */
    isLeapMonth: boolean;
}
type Optionalize<T, K extends keyof T> = Omit<T, K> & {
    [P in K]?: T[P];
};

/**
 * Checks if a given lunar date is valid. A lunar date consists of a year, month, and day, and optionally a leap month
 * flag. This function ensures that the lunar date is an object with valid year, month, and day values, and that the
 * date falls within the valid lunar calendar range.
 * @param {*} lunar - The lunar date to check. It should be an object with properties `year`, `month`, `day`, and
 *     optionally `isLeapMonth`.
 * @returns {boolean} True if the lunar date is valid, otherwise false.
 *
 * @example
 * // => true
 * isValidLunar({ year: 2024, month: 1, day: 1 })
 *
 * @example
 * // => true
 * isValidLunar({ year: 2024, month: 1, day: 1, isLeapMonth: false })
 *
 * @example
 * // => false
 * isValidLunar({ year: 2025, month: 1 })
 *
 * @example
 * // => false
 * isValidLunar({ year: 2100, month: 12, day: 2 })
 */
declare function isValidLunar(lunar: unknown): lunar is LunarDate;

/**
 * Checks if a given date is a valid solar date within the range from January 31, 1900 to December 31, 2100. This
 * function first ensures that the date is a valid `Date` object and then checks whether it falls within the specified
 * range.
 * @param {*} date - The value to check.
 * @returns {boolean} True if the date is a valid solar date, otherwise false.
 *
 * @example
 * // => true
 * isValidSolar(new Date('2025-01-1T00:00:00Z'))
 *
 * @example
 * // => false
 * isValidSolar(new Date('1900-01-30T00:00:00Z'))
 *
 * @example
 * // => false
 * isValidSolar(new Date('2101-01-01T00:00:00Z'))
 */
declare function isValidSolar(date: unknown): date is Date;

/**
 * Converts a given `Date` object to a GMT date, removing any time information. This function sets the time to
 * `00:00:00` UTC for the specified date, effectively stripping off the time part.
 * @param {Date} date - The `Date` object to convert.
 * @returns {Date} A new `Date` object representing the same day in GMT with the time set to `00:00:00`.
 *
 * @example
 * // => Date representing '2024-01-01T00:00:00.000Z'
 * toGMTDate(new Date('2024-01-01T00:00:00.000Z+08:00'))
 *
 * @example
 * // => Date representing '2024-01-01T00:00:00.000Z'
 * toGMTDate(new Date('2024-01-01T00:00:00.000Z-08:00'))
 */
declare function toGMTDate(date: Date): Date;

/**
 * Converts a given solar (Gregorian) date to a lunar (Chinese) date. The function calculates the corresponding lunar
 * year, month, day, and whether the month is a leap month. If the solar date is invalid or out of range, it returns
 * -1.
 * @param {Date} date - The solar date to convert. It should be a valid JavaScript `Date` object.
 * @returns {LunarDate | -1} A LunarDate object representing the corresponding lunar date, or -1 if the solar date is
 *     invalid.
 *
 * @example
 * // => { year: 2024, month: 2, day: 10, isLeapMonth: false }
 * toLunar(new Date('2024-01-01'))
 *
 * @example
 * // => -1
 * toLunar(new Date('1900-01-30'))
 *
 * @example
 * // => -1
 * toLunar(new Date('2101-01-01'))
 */
declare function toLunar(date: Date): LunarDate | -1;

/**
 * Converts a given lunar date to a solar (Gregorian) date. The function calculates the corresponding solar year,
 * month, and day from the lunar date. If the lunar date is invalid or out of range, it returns -1.
 * @param {LunarDate} lunar - The lunar date object to convert. It should be a valid `LunarDate` object.
 * @returns {Date | -1} A `Date` object representing the corresponding solar date, or -1 if the lunar date is invalid.
 *
 * @example
 * // => 2025-01-30T00:00:00.000Z
 * toSolar({ year: 2025, month: 1, day: 30, isLeapMonth: false })
 *
 * @example
 * // => -1
 * toSolar({ year: 1900, month: 1, day: 30, isLeapMonth: false })
 */
declare function toSolar(lunar: LunarDate): Date | -1;

export { type LunarDate, type Optionalize, index as constants, getLeapMonth, getLeapMonthDays, getMonthDays, getYearDays, isDate, isValidDate, isValidLunar, isValidSolar, toGMTDate, toLunar, toSolar };
